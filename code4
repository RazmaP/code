It looks like we need to ensure all original functionality is included and address the errors. Specifically, the errors related to getRowNodeId and rowData type should be corrected. Here is the updated code with necessary corrections:

app.component.html
html
Copy code
<div class="example-wrapper" style="width: 100%; height: 100%; overflow-x: auto;">
    <div style="margin-bottom: 5px;">
        <input id="filter-text-box" placeholder="Filter..." (input)="onFilterTextBoxChanged()">
        <button (click)="expandAll()">Expand All</button>
        <button (click)="collapseAll()">Collapse All</button>
        <input type="date" id="start-date-input" (change)="onStartDateChange($event)">
        <input type="date" id="end-date-input" (change)="onEndDateChange($event)">
        <button (click)="fetchDataByDateRange()">By Date Range</button>
    </div>
    <ag-grid-angular
        style="width: 100%; height: calc(100% - 40px);"
        id="myGrid"
        [gridOptions]="gridOptions"
        class="ag-theme-alpine"
        [columnDefs]="columnDefs"
        [defaultColDef]="defaultColDef"
        [autoGroupColumnDef]="autoGroupColumnDef"
        [rowData]="rowData | async"
        [groupDefaultExpanded]="groupDefaultExpanded"
        [getDataPath]="getDataPath"
        (firstDataRendered)="onFirstDataRendered($event)"
        (gridReady)="onGridReady($event)">
    </ag-grid-angular>
</div>
app.component.ts
typescript
Copy code
import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { ColDef, GridApi, GridReadyEvent, GridOptions } from 'ag-grid-community';
import { Observable, of } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { DatePipe } from '@angular/common';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss'],
  providers: [DatePipe]
})
export class AppComponent implements OnInit {
  private gridApi!: GridApi;
  public startDate: string = '';
  public endDate: string = '';
  public columnDefs: ColDef[] = [
    { field: 'isx_create_date', headerName: 'ISX Create Date', flex: 1 },
    { field: 'portfolio_ticker', flex: 1 },
    { field: 'ticker', flex: 1 },
    { field: 'secId', flex: 1 },
    { field: 'assetId', flex: 1 },
    { field: 'fileName', flex: 2 },
    { field: 'security_name', flex: 2 },
    { field: 'price_date', flex: 1 },
    { field: 'price', flex: 1 },
    { field: 'quantity', flex: 1 },
    { field: 'new_quantity', flex: 1 },
    { field: 'rounded_pct_portfolio_weight', flex: 2 },
    { field: 'rounded_pct_new_portfolio_weight', flex: 2 },
    { field: 'recalc_portfolio_weight', flex: 2 },
    { field: 'recalc_new_portfolio_weight', flex: 2 },
    { field: 'rounded_pct_change_in_portfolio_weight', flex: 2 },
    { field: 'sec_type', flex: 1 }
  ];
  public defaultColDef: ColDef = {
    sortable: true,
    filter: true,
    flex: 1,
  };
  public autoGroupColumnDef: ColDef = {
    headerName: 'ModelTranId / FileName / PortfolioName',
    minWidth: 300,
    cellRendererParams: {
      suppressCount: true,
      innerRenderer: (params: any) => {
        if (params.node.group) {
          return `${params.value} (${params.node.allChildrenCount})`;
        }
        return params.value;
      }
    }
  };
  public rowData: Observable<any[]> = of([]);
  public groupDefaultExpanded = 0;

  public gridOptions: GridOptions = {
    suppressDragLeaveHidesColumns: true,
    getRowId: params => params.data.id
  };

  constructor(private http: HttpClient, private datePipe: DatePipe) {}

  ngOnInit() {}

  onGridReady(params: GridReadyEvent) {
    this.gridApi = params.api;
  }

  onFirstDataRendered(params: GridReadyEvent) {
    params.api.sizeColumnsToFit();
  }

  onFilterTextBoxChanged() {
    this.gridApi.setQuickFilter((document.getElementById('filter-text-box') as any).value);
  }

  expandAll() {
    this.gridApi.expandAll();
  }

  collapseAll() {
    this.gridApi.collapseAll();
  }

  onStartDateChange(event: any) {
    const rawDate = event.target.value;
    this.startDate = this.datePipe.transform(rawDate, 'yyyy-MM-dd') || '';
  }

  onEndDateChange(event: any) {
    const rawDate = event.target.value;
    this.endDate = this.datePipe.transform(rawDate, 'yyyy-MM-dd') || '';
  }

  fetchDataByDateRange() {
    this.rowData = this.http.get<any[]>(`http://localhost:8080/api/new-model-transactions?start_date=${this.startDate}&end_date=${this.endDate}`).pipe(
      map(data => this.transformData(data)),
      catchError(error => {
        console.error('Error fetching data by date range', error);
        return of([]);
      })
    );
  }

  getDataPath(data: any): string[] {
    return data.orgHierarchy;
  }

  transformData(data: any[]): any[] {
    return data.map((item, index) => ({
      id: index + 1,
      orgHierarchy: [
        item.modelTranId.toString(),
        item.fileName,
        item.portfolioName,
      ],
      modelTranId: item.modelTranId,
      isx_create_date: new Date(item.isx_create_date).toLocaleDateString(),
      portfolio_ticker: item.portfolio_ticker,
      ticker: item.ticker,
      secId: item.secId,
      assetId: item.assetId,
      fileName: item.fileName,
      security_name: item.security_name,
      price_date: new Date(item.price_date).toLocaleDateString(),
      price: item.price,
      quantity: item.quantity,
      new_quantity: item.new_quantity,
      rounded_pct_portfolio_weight: item.rounded_pct_portfolio_weight,
      rounded_pct_new_portfolio_weight: item.rounded_pct_new_portfolio_weight,
      recalc_portfolio_weight: item.recalc_portfolio_weight,
      recalc_new_portfolio_weight: item.recalc_new_portfolio_weight,
      rounded_pct_change_in_portfolio_weight: item.rounded_pct_change_in_portfolio_weight,
      sec_type: item.sec_type,
    }));
  }
}
