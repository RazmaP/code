import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { ColDef, GridApi, GridReadyEvent, GridOptions } from 'ag-grid-community';
import { Observable, of } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { DatePipe } from '@angular/common';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss'],
  providers: [DatePipe]
})
export class AppComponent implements OnInit {
  private gridApi!: GridApi;
  public startDate: string = '';
  public endDate: string = '';
  public columnDefs: ColDef[] = [
    { field: 'isx_create_date', headerName: 'ISX Create Date', flex: 1 },
    { field: 'portfolio_ticker', flex: 1 },
    { field: 'ticker', flex: 1 },
    { field: 'secId', flex: 1 },
    { field: 'assetId', flex: 1 },
    { field: 'fileName', flex: 2 },
    { field: 'security_name', flex: 2 },
    { field: 'price_date', flex: 1 },
    { field: 'price', flex: 1 },
    { field: 'quantity', flex: 1 },
    { field: 'new_quantity', flex: 1 },
    { field: 'rounded_pct_portfolio_weight', flex: 2 },
    { field: 'rounded_pct_new_portfolio_weight', flex: 2 },
    { field: 'recalc_portfolio_weight', flex: 2 },
    { field: 'recalc_new_portfolio_weight', flex: 2 },
    { field: 'rounded_pct_change_in_portfolio_weight', flex: 2 },
    { field: 'sec_type', flex: 1 }
  ];
  public defaultColDef: ColDef = {
    sortable: true,
    filter: true,
    flex: 1,
  };
  public autoGroupColumnDef: ColDef = {
    headerName: 'ModelTranId / FileName / PortfolioName',
    minWidth: 300,
    cellRendererParams: {
      suppressCount: true,
      innerRenderer: (params: any) => {
        if (params.node.group) {
          return `${params.value} (${params.node.allChildrenCount})`;
        }
        return params.value;
      }
    }
  };
  public rowData: Observable<any[]> = of([]);
  public groupDefaultExpanded = 0;

  public gridOptions: GridOptions = {
    suppressDragLeaveHidesColumns: true,
    getRowId: params => params.data.id
  };

  constructor(private http: HttpClient, private datePipe: DatePipe) {}

  ngOnInit() {}

  onGridReady(params: GridReadyEvent) {
    this.gridApi = params.api;
  }

  onFirstDataRendered(params: GridReadyEvent) {
    params.api.sizeColumnsToFit();
  }

  onFilterTextBoxChanged() {
    this.gridApi.setQuickFilter((document.getElementById('filter-text-box') as any).value);
  }

  expandAll() {
    this.gridApi.expandAll();
  }

  collapseAll() {
    this.gridApi.collapseAll();
  }

  onStartDateChange(event: any) {
    const rawDate = event.target.value;
    this.startDate = this.datePipe.transform(rawDate, 'yyyy-MM-dd') || '';
  }

  onEndDateChange(event: any) {
    const rawDate = event.target.value;
    this.endDate = this.datePipe.transform(rawDate, 'yyyy-MM-dd') || '';
  }

  fetchDataByDateRange() {
    if (!this.startDate || !this.endDate) {
      console.error('Start date and end date must be provided.');
      return;
    }

    console.log(`Fetching data from ${this.startDate} to ${this.endDate}`);

    this.rowData = this.http.get<any[]>(`http://localhost:8080/api/new-model-transactions?start_date=${this.startDate}&end_date=${this.endDate}`).pipe(
      map(data => {
        console.log('Data received from API:', data);
        return this.transformData(data);
      }),
      catchError(error => {
        console.error('Error fetching data by date range', error);
        return of([]);
      })
    );
  }

  getDataPath(data: any): string[] {
    return data.orgHierarchy;
  }

  transformData(data: any[]): any[] {
    return data.map((item, index) => ({
      id: index + 1,
      orgHierarchy: [
        item.modelTranId.toString(),
        item.fileName,
        item.portfolioName,
      ],
      modelTranId: item.modelTranId,
      isx_create_date: new Date(item.isx_create_date).toLocaleDateString(),
      portfolio_ticker: item.portfolio_ticker,
      ticker: item.ticker,
      secId: item.secId,
      assetId: item.assetId,
      fileName: item.fileName,
      security_name: item.security_name,
      price_date: new Date(item.price_date).toLocaleDateString(),
      price: item.price,
      quantity: item.quantity,
      new_quantity: item.new_quantity,
      rounded_pct_portfolio_weight: item.rounded_pct_portfolio_weight,
      rounded_pct_new_portfolio_weight: item.rounded_pct_new_portfolio_weight,
      recalc_portfolio_weight: item.recalc_portfolio_weight,
      recalc_new_portfolio_weight: item.recalc_new_portfolio_weight,
      rounded_pct_change_in_portfolio_weight: item.rounded_pct_change_in_portfolio_weight,
      sec_type: item.sec_type,
    }));
  }
}
