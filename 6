<div class="example-wrapper" style="width: 100%; height: 100%; overflow-x: auto;">
    <div style="margin-bottom: 5px">
        <input type="text" id="filter-text-box" placeholder="Filter..." (input)="onFilterTextBoxChanged()" />
        <button (click)="expandAll()">Expand All</button>
        <button (click)="collapseAll()">Collapse All</button>
        <input type="date" id="start-date-input" (change)="onStartDateChange($event)" />
        <input type="date" id="end-date-input" (change)="onEndDateChange($event)" />
        <button (click)="fetchDataByDateRange()">Search by Date Range</button>
    </div>
    <div style="width: 100%; height: 80%;">
        <ag-grid-angular
            style="width: 100%; height: 100%;"
            class="ag-theme-alpine"
            [columnDefs]="columnDefs"
            [defaultColDef]="defaultColDef"
            [autoGroupColumnDef]="autoGroupColumnDef"
            [rowData]="rowData$ | async"
            [groupDefaultExpanded]="-1"
            [getDataPath]="getDataPath"
            (gridReady)="onGridReady($event)"
            (firstDataRendered)="onFirstDataRendered($event)">
        </ag-grid-angular>
    </div>
</div>
Explanation:
Filter Input and Buttons:

The filter input allows the user to filter the rows in the grid.
The "Expand All" and "Collapse All" buttons allow the user to expand or collapse all the grouped rows.
Date Inputs:

These inputs allow the user to select a start date and an end date for fetching the data.
ag-Grid Angular Component:

This is the main ag-Grid component that displays the data.
The [columnDefs], [defaultColDef], and [autoGroupColumnDef] properties define the columns and their default behavior.
The [rowData] property is bound to the transformed data.
The [groupDefaultExpanded] property is set to -1 to expand all groups by default.
The (gridReady) and (firstDataRendered) events are used to handle grid initialization and rendering events.
getDataPath Function:
In your app.component.ts, add the getDataPath function to define the path structure for the hierarchical data.

typescript
Copy code
getDataPath = (data: any) => {
  return [data.isx_create_date, data.modelTranId];
};
Full app.component.ts (with getDataPath):
typescript
Copy code
import { Component, OnInit } from '@angular/core';
import { ColDef, GridApi, GridReadyEvent } from 'ag-grid-community';
import { Observable, of, forkJoin } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { DatePipe } from '@angular/common';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss'],
  providers: [DatePipe]
})
export class AppComponent implements OnInit {
  private gridApi!: GridApi;
  startDate!: string;
  endDate!: string;

  public columnDefs: ColDef[] = [
    { field: 'isx_create_date', headerName: 'ISX Create Date', rowGroup: true, hide: true },
    { field: 'modelTranId', headerName: 'ModelTranId', rowGroup: true, hide: true },
    { field: 'file_name', headerName: 'File Name', flex: 1 },
    { field: 'portfolio_name', headerName: 'Portfolio Name', flex: 1 },
    { field: 'ticker', headerName: 'Ticker', flex: 1 },
    { field: 'sedol', headerName: 'SEDOL', flex: 1 },
    { field: 'security_name', headerName: 'Security Name', flex: 1 },
    { field: 'asset_id', headerName: 'Asset ID', flex: 1 },
    { field: 'price', headerName: 'Price', flex: 1 },
    { field: 'price_date', headerName: 'Price Date', flex: 1 },
    { field: 'quantity', headerName: 'Quantity', flex: 1 },
    { field: 'new_quantity', headerName: 'New Quantity', flex: 1 },
    { field: 'rounded_pct_portfolio_weight', headerName: 'Rounded PCT Portfolio Weight', flex: 2 },
    { field: 'recalc_portfolio_weight', headerName: 'Recalc Portfolio Weight', flex: 2 },
    { field: 'aladdin_portfolio_weight', headerName: 'Aladdin Portfolio Weight', flex: 2 },
    { field: 'recalc_pct_new_portfolio_weight', headerName: 'Recalc PCT New Portfolio Weight', flex: 2 },
    { field: 'rounded_pct_new_portfolio_weight', headerName: 'Rounded PCT New Portfolio Weight', flex: 2 },
    { field: 'rounded_pct_change_in_portfolio_weight', headerName: 'Rounded PCT Change in Portfolio Weight', flex: 2 },
    { field: 'sec_type', headerName: 'SEC Type', flex: 1 },
  ];

  public defaultColDef: ColDef = {
    sortable: true,
    filter: true
  };

  public autoGroupColumnDef: ColDef = {
    headerName: 'Group',
    cellRendererParams: {
      suppressCount: true,
    }
  };

  public rowData$: Observable<any[]> = of([]);

  constructor(private http: HttpClient, private datePipe: DatePipe) {}

  ngOnInit(): void {}

  transformData(firstGridData: any[], secondGridData: any[]): any[] {
    const combinedData = firstGridData.map(item => {
      const relatedData = secondGridData.filter(d => d.modelTranId === item.modelTranId);
      return {
        isx_create_date: item.isx_create_date,
        modelTranId: `${item.modelTranId}-${item.file_name}-${item.portfolio_name}`,
        children: relatedData.map(d => ({
          ...d,
          isx_create_date: item.isx_create_date
        }))
      };
    });
    return combinedData;
  }

  getDataPath = (data: any) => {
    return [data.isx_create_date, data.modelTranId];
  };

  onFilterTextBoxChanged() {
    this.gridApi.setQuickFilter((document.getElementById('filter-text-box') as any).value);
  }

  expandAll() {
    this.gridApi.expandAll();
  }

  collapseAll() {
    this.gridApi.collapseAll();
  }

  onStartDateChange(event: any) {
    const rawDate = event.target.value;
    this.startDate = this.datePipe.transform(rawDate, 'yyyy-MM-dd') || '';
  }

  onEndDateChange(event: any) {
    const rawDate = event.target.value;
    this.endDate = this.datePipe.transform(rawDate, 'yyyy-MM-dd') || '';
  }

  fetchDataByDateRange() {
    const firstGridData$ = this.http.get<any[]>(`http://localhost:8080/api/new-model-transactions/dto?start_date=${this.startDate}&end_date=${this.endDate}`).pipe(
      map(data => this.transformFirstGridData(data)),
      catchError(error => {
        console.error('Error fetching first grid data by date range', error);
        return of([]);
      })
    );

    const secondGridData$ = this.http.get<any[]>(`http://localhost:8080/api/new-model-transactions?start_date=${this.startDate}&end_date=${this.endDate}`).pipe(
      map(data => this.transformData(data)),
      catchError(error => {
        console.error('Error fetching second grid data by date range', error);
        return of([]);
      })
    );

    forkJoin([firstGridData$, secondGridData$]).pipe(
      map(([firstGridData, secondGridData]) => this.transformData(firstGridData, secondGridData)),
      catchError(error => {
        console.error('Error combining data', error);
        return of([]);
      })
    ).subscribe(combinedData => this.rowData$ = of(combinedData));
  }

  onGridReady(params: GridReadyEvent) {
    this.gridApi = params.api;
  }

  onFirstDataRendered(params: any) {
    params.api.sizeColumnsToFit();
  }
}
